# Elm изменил мое представление о непопулярных языках

*Перевод статьи [Alexander Campbell](https://blog.realkinetic.com/@alexandercampbell): [Elm changed my mind about unpopular languages](https://blog.realkinetic.com/elm-changed-my-mind-about-unpopular-languages-190a23f4a834)*

![](./background.png)

Вы когда-нибудь обращались к программному обеспечению так, чтобы это выходило за рамки обыденного? Возможно, вы пытались сделать программное обеспечение для своего [графического калькулятора Fx-9860GX](https://wiki.planet-casio.com/en/Fx-9860G_SDK) и понимали, что вы были одним из тех пяти человек, которые когда-либо пытались это сделать вообще, при том, что документации не было. Опыт отстойный. Или возможно вы относитесь к такому типу людей, которые получают удовольствие посредством мудреных ошибок и полного отсутствия документации (к коим иногда отношусь и я), но я решил, что в профессиональной разработке программного обеспечения, где важен вопрос его поставки на рынок, я буду придерживаться только самых широко используемых инструментов.

Для себя я сделал твердое и решительное правило: если я найду две технологии, которые могут решить какую-то проблему, то я предпочту ту, которой пользуется больше людей. К слову, я не хотел бы включать в проект неясный API для работы с графикой, а затем искать в коде, чтобы никто не вызывал функцию `set_color()` после функции `resize_window()` (да, изменение размеров окна это [тяжело](https://bugreports.qt.io/browse/QTBUG-57608)), ведь последовательное выполнение этих двух функций является причиной [ошибки сегментации памяти](https://bugreports.qt.io/browse/QTBUG-60185). Я не хочу быть парнем, который найдет [ошибку в компиляторе](https://github.com/golang/go/issues/1990). Мне просто нужно разработать программный продукт.

Частично мое сомнение по поводу использования новых платформ связано с двухлетним опытом написание на языке Go, до того как произошла история с управлением зависимостей. Сообщество было разбито на множеством болезненных или посредственных решений: gopkg.in, godep, glide, gb и так далее. Потребовалось годы, чтобы разработчики «успокоились» (да, я легко бросаюсь этим словом) и остановилось на godep, а ведь это было не так недавно, когда сообщество Go его полностью приняло, это был относительно безболезненный опыт. И недавно я узнал, что разработчики языка Go могут представить официальное решение: [golang/dep](https://github.com/golang/dep).

Со своим новым правилом я чувствовал себя уверенным в выборе своего стека. Когда я искал инструменты для создания веб-приложения, то рассматривал только массово используемые и популярные инструменты, такие как Bootstrap и jQuery. У каждой из этих библиотек несметное число пользователей каждый месяц, поэтому все возможные ошибки проработаны, не так ли? Даже если, у меня возникнет проблема, уверен, кто-то уже получал ответ на нее на StackOverflow. Все как по маслу. И вуаля, все уже работает. Вы можете пройтись по всему жизненному циклу веб-приложения, и вы редко столкнетесь с ситуацией, когда вы не можете найти решение проблемы в течение 5 секунд в сети. Кто-то уже исправил это. Моя стратегия была безупречной.

Но когда я присоединился к Real Kinetic, я узнал, что мы разрабатываем клиентское веб-приложение на [Elm](http://elm-lang.org/). Elm? Серьезно? Это же экспериментальный язык, созданный для Haskell-снобов, которые не могут справиться с обычным языком для синих воротничков, таким как JavaScript? Я представлял поклонников языка Elm так, словно вокруг меня стояли хипстеры, говорящие о том, что побочные эффекты в веб-приложениях — это же 2008 год, бро. Определенно, я не представлял их как людей, которые поставляют приложения на рынок программного обеспечения. На мой взгляд, Elm не соответствовал производственной среде.

Поэтому в течение первых нескольких недель я был настроен скептически. Но затем, когда я в третий раз изучал руководство по [архитектуре Elm](https://guide.elm-lang.org/architecture/), наконец, что-то щелкнуло у меня в голове. Я понял. Вот это да! Да это же намного лучше, чем JavaScript. Я могу посмотреть на код и с уверенностью предсказывать его поведение, его пограничные случаи и все остальное.

Во-первых, Elm имеет естественную для чистого функционального языка предсказуемость; когда вы пишете Elm, компилятор заставляет вас обдумывать каждый случай. Рассмотрим следующий пример: для своего друга вы пишете некоторое приложение для учета книг в библиотеке. Он хочет возможность получать отчет, в котором бы отображалось, сколько книг находится в каталоге, дата издания самой ранней и самой поздней книги в библиотеке и количество уникальных авторов.

https://gist.github.com/ufocoder/45d16524932a5256b55c1ae0dcf583eb

Я могу более подробно рассмотреть этот код. Например, вот этот фрагмент:

https://gist.github.com/ufocoder/a261fd07fe7f574a74a0fc83faf38c18

Здесь мы используем две библиотечные функции: `List.maximum` и `Maybe.withDefault`. Назначение и использовании функции `List.maximum` очевидны, также его [сигнатура типа](https://github.com/elm-lang/core/blob/9a20adc5749c1e68986771c506f0bef7ade9903f/src/List.elm#L391) является показательной.

https://gist.github.com/ufocoder/b4fba2e095f968568186f13684317750

В данном случае, поскольку наш список имеет тип «List Int», функция возвращает «Maybe Int». Концепция использования `Maybe` знакома людям пришедшим из Haskell (Maybe), из Rust (Option) или из Java (Optional). `Maybe` — это контейнер с нулевым (Nothing) или одним (Just x) элементом. Мы можем использовать функцию `Maybe.withDefault` для «распаковки» значения `Maybe`, заменяя на значение по умолчанию, если контейнер `Maybe` пуст.

Таким образом, этот фрагмент кода извлекает максимальное значение в списке `copyrightYears`, если оно существует. Если же нет, мы просто возвращаем ноль. Elm требует, чтобы вы продумали все пограничные случаи. **Вы должны рассмотреть и указать, что произойдет в каждом случае**. Именно по этой причине Elm может реально обещать отсутствие исключений во времени выполнения.

Вторая причина, почему Elm лучше, чем JavaScript — это то, что Elm естественно подходит для работы с DOM. Это настолько естественное чувство, что кажется, что HTML был разработан специально для Elm, но не наоборот. Отчасти причина заключается в том, что Elm использует концепцию виртуального DOM, с которой вы можете быть знакомы, если сталкивались с React (именно виртуальный DOM является причиной, почему представление может быть автоматически обновлено с помощью измененной модели приложения. *Примечание редактора — В данном случае кажется, что автор заблуждается. Виртуальный DOM нужен для снижения стоимости таких обновлений*). Здесь показано то, как мы можем отобразить тип `LibraryReport` в HTML:

https://gist.github.com/ufocoder/96732371e7cccfe080bf673ca7992d6b

Обратите внимание на то, как мы составили функцию `renderRow` включающую `viewReport`. Отображаемый результат:

![](https://cdn-images-1.medium.com/max/1600/0*Bfpi30J-B56glbZq.)

Разработка с Elm — это сплошная череда приятных сюрпризов: элегантный интерфейс командной строки, полезный при разработке компилятор, интуитивно понятный отладчик.

К числу этих неожиданностей относятся (спойлеры):

* Элегантный интерфейс командной строки `elm-package` и `elm-make`.
* Автоматическое форматирование кода с помощью `elm-format` (похоже на [gofmt](https://blog.golang.org/go-fmt-your-code)).
* Автоматическое принудительное версионирование пакетов по [semver](https://semver.org/).
* Elm-Reactor, отличный способ начать разрабатывать новые проекты.
* Режим отладки в Elm со встроенным [time-travel](https://www.youtube.com/watch?v=vS3yzUo7l8Y).

![](https://cdn-images-1.medium.com/max/1600/0*Nvtop5fMg_OffOk3. "Сообщение компилятора, когда вы удалите поле из структуры без обновления связанных с ней функций.")

Самыми большими минусами Elm являются то, что:

1. Это функциональный язык, и поэтому кривая обучения круче для тех программистов, кто пришел из императивных языков.

2. Вероятно, вы не сможете использовать его на стороне сервера (язык не такой универсальный, как JavaScript).

3. В нем отсутствуют некоторые высокоуровневые возможности других функциональных языков, таких как в Haskell.

4. Строгая семантика зависимостей накладывает ограничение на разработчиков библиотек для Elm по немедленному их обновлению, когда зависимости изменились, чтобы не блокировать последующие обновления.

Вам кажется, что здесь чего-то не хватает? Даже несмотря на то, что Elm — небольшой язык с небольшим сообществом, это никак не влияет заметным образом на опыт разработки на Elm.

Теперь я решительно отдаю предпочтение Elm для любого нового клиентского веб-приложения. Elm обладает и другими преимуществами, которые лежат на поверхности, такими как [высокая производительность](http://elm-lang.org/blog/blazing-fast-html), [достойная поддержка библиотек](http://package.elm-lang.org/), а также продуманный [дизайн взаимодействия с JavaScript](https://guide.elm-lang.org/interop/javascript.html), но для меня преимущество в Elm — это то, что он дает мне уверенность в моем коде.

- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*
